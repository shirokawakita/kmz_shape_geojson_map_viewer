<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMZ, Shape and GeoJSON Map Viewer</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            background-color: #f5f5f5;
        }
        
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .controls {
            background-color: white;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .file-input-group label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .file-input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        .file-input:hover {
            border-color: #3498db;
        }
        
        .clear-btn {
            padding: 10px 20px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .clear-btn:hover {
            background-color: #c0392b;
        }
        
        .map-container {
            position: relative;
        }
        
        #map {
            height: calc(100vh - 160px);
            width: 100%;
        }
        
        .layer-control {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 160px;
        }
        
        .layer-control h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .layer-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .layer-item input[type="checkbox"],
        .layer-item input[type="radio"] {
            cursor: pointer;
        }
        
        .layer-item label {
            cursor: pointer;
            font-size: 14px;
        }
        
        .polygon-control {
            border-left: 2px solid #e0e0e0;
            padding-left: 8px !important;
            margin-left: 12px !important;
        }
        
        .polygon-control label {
            color: #666 !important;
            font-size: 13px !important;
        }
        
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        .loading {
            display: block !important;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .layer-control {
                position: relative;
                margin: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ—ºï¸ KMZ, Shape and GeoJSON Map Viewer</h1>
        <p style="margin: 5px 0 0 0; font-size: 14px;">Display KMZ, Shape, and GeoJSON files on GSI maps</p>
    </div>
    
    <div class="controls">
        <div class="file-input-group">
            <label for="kmzFile">KMZãƒ•ã‚¡ã‚¤ãƒ«</label>
            <input type="file" id="kmzFile" class="file-input" accept=".kmz" />
        </div>
        
        <div class="file-input-group">
            <label for="shapeFile">Shapeãƒ•ã‚¡ã‚¤ãƒ« (ZIP)</label>
            <input type="file" id="shapeFile" class="file-input" accept=".zip" />
        </div>
        
        <div class="file-input-group">
            <label for="geojsonFile">GeoJSONãƒ•ã‚¡ã‚¤ãƒ«</label>
            <input type="file" id="geojsonFile" class="file-input" accept=".geojson,.json" />
        </div>
        
        <button id="clearLayers" class="clear-btn">ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢</button>
    </div>
    
    <div class="map-container">
        <div id="map"></div>
        
        <div class="layer-control">
            <h3>èƒŒæ™¯åœ°å›³</h3>
            <div class="layer-item">
                <input type="radio" id="std" name="basemap" value="std" checked>
                <label for="std">æ¨™æº–åœ°å›³</label>
            </div>
            <div class="layer-item">
                <input type="radio" id="pale" name="basemap" value="pale">
                <label for="pale">æ·¡è‰²åœ°å›³</label>
            </div>
            <div class="layer-item">
                <input type="radio" id="photo" name="basemap" value="photo">
                <label for="photo">å†™çœŸ</label>
            </div>
            
            <h3 style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 15px;">ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤</h3>
            <div class="layer-item">
                <input type="checkbox" id="kmzLayer" checked>
                <label for="kmzLayer">KMZãƒ¬ã‚¤ãƒ¤ãƒ¼</label>
            </div>
            <div id="shapeLayerControls">
                <div class="layer-item">
                    <input type="checkbox" id="shapeLayer" checked>
                    <label for="shapeLayer">Shapeãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå…¨ä½“ï¼‰</label>
                </div>
            </div>
            <div id="geojsonLayerControls">
                <div class="layer-item">
                    <input type="checkbox" id="geojsonLayer" checked>
                    <label for="geojsonLayer">GeoJSONãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå…¨ä½“ï¼‰</label>
                </div>
            </div>
        </div>
        
        <div id="status" class="status">èª­ã¿è¾¼ã¿ä¸­...</div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- JSZip for handling ZIP files -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Shapefile.js for handling Shapefiles -->
    <script src="https://unpkg.com/shapefile@0.6.6/dist/shapefile.js"></script>
    <!-- toGeoJSON for KML/KMZ conversion -->
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>

    <script>
        // åœ°å›³ã®åˆæœŸåŒ–
        const map = L.map('map').setView([35.6762, 139.6503], 10); // æ±äº¬ã‚’ä¸­å¿ƒã«è¨­å®š

        // å›½åœŸåœ°ç†é™¢åœ°å›³ã®ã‚¿ã‚¤ãƒ«å®šç¾©
        const baseMaps = {
            std: L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.gsi.go.jp/">å›½åœŸåœ°ç†é™¢</a>',
                maxZoom: 18
            }),
            pale: L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.gsi.go.jp/">å›½åœŸåœ°ç†é™¢</a>',
                maxZoom: 18
            }),
            photo: L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', {
                attribution: '&copy; <a href="https://www.gsi.go.jp/">å›½åœŸåœ°ç†é™¢</a>',
                maxZoom: 18
            })
        };

        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æ¨™æº–åœ°å›³ã‚’è¡¨ç¤º
        let currentBaseMap = baseMaps.std.addTo(map);

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã®ç®¡ç†
        const overlayLayers = {
            kmz: L.layerGroup(),
            shape: L.layerGroup(),
            geojson: L.layerGroup(),
            shapePolygons: [], // å€‹åˆ¥ã®ãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¿å­˜
            geojsonPolygons: [] // å€‹åˆ¥ã®GeoJSONãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¿å­˜
        };

        // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœ°å›³ã«è¿½åŠ ï¼ˆãƒãƒªã‚´ãƒ³é…åˆ—ã¯é™¤å¤–ã€shape/geojsonã¯ä½¿ç”¨ã—ãªã„ï¼‰
        overlayLayers.kmz.addTo(map);

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºé–¢æ•°
        function showStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.classList.add('loading');
        }

        function hideStatus() {
            const status = document.getElementById('status');
            status.classList.remove('loading');
        }

        // ãƒãƒªã‚´ãƒ³ã®é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function isDuplicatePolygon(feature1, feature2) {
            // GeoJSONã®geometryã‚’æ¯”è¼ƒ
            if (!feature1.geometry || !feature2.geometry) return false;
            
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ã—ã¦æ¯”è¼ƒ
            const bounds1 = L.geoJSON(feature1).getBounds();
            const bounds2 = L.geoJSON(feature2).getBounds();
            
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ãŒå®Œå…¨ã«ä¸€è‡´ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const tolerance = 0.000001; // åº§æ¨™ã®è¨±å®¹èª¤å·®
            return Math.abs(bounds1.getNorth() - bounds2.getNorth()) < tolerance &&
                   Math.abs(bounds1.getSouth() - bounds2.getSouth()) < tolerance &&
                   Math.abs(bounds1.getEast() - bounds2.getEast()) < tolerance &&
                   Math.abs(bounds1.getWest() - bounds2.getWest()) < tolerance;
        }

        // é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’é™¤å»ã™ã‚‹é–¢æ•°
        function removeDuplicateFeatures(features) {
            const uniqueFeatures = [];
            const duplicateIndices = new Set();
            
            for (let i = 0; i < features.length; i++) {
                if (duplicateIndices.has(i)) continue;
                
                let isDuplicate = false;
                for (let j = 0; j < uniqueFeatures.length; j++) {
                    if (isDuplicatePolygon(features[i], uniqueFeatures[j])) {
                        isDuplicate = true;
                        break;
                    }
                }
                
                if (!isDuplicate) {
                    uniqueFeatures.push(features[i]);
                } else {
                    duplicateIndices.add(i);
                }
            }
            
            return uniqueFeatures;
        }

        // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆShapeç”¨ï¼‰
        function updateShapeLayerMasterCheckbox() {
            const masterCheckbox = document.getElementById('shapeLayer');
            const polygonCheckboxes = document.querySelectorAll('[id^="shapePolygon_"]');
            
            if (polygonCheckboxes.length === 0) {
                masterCheckbox.checked = false;
                return;
            }
            
            const checkedCount = Array.from(polygonCheckboxes).filter(cb => cb.checked).length;
            masterCheckbox.checked = checkedCount === polygonCheckboxes.length;
        }

        // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆGeoJSONç”¨ï¼‰
        function updateGeoJSONLayerMasterCheckbox() {
            const masterCheckbox = document.getElementById('geojsonLayer');
            const polygonCheckboxes = document.querySelectorAll('[id^="geojsonPolygon_"]');
            
            if (polygonCheckboxes.length === 0) {
                masterCheckbox.checked = false;
                return;
            }
            
            const checkedCount = Array.from(polygonCheckboxes).filter(cb => cb.checked).length;
            masterCheckbox.checked = checkedCount === polygonCheckboxes.length;
        }

        // Shapeãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’å‹•çš„ã«æ›´æ–°
        function updateShapePolygonControls() {
            const controlsContainer = document.getElementById('shapeLayerControls');
            
            // æ—¢å­˜ã®å€‹åˆ¥ãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’å‰Šé™¤
            const existingPolygonControls = controlsContainer.querySelectorAll('.polygon-control');
            existingPolygonControls.forEach(control => control.remove());

            // å„ãƒãƒªã‚´ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¿½åŠ 
            overlayLayers.shapePolygons.forEach((polygonData, index) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'layer-item polygon-control';
                controlDiv.style.marginLeft = '20px'; // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `shapePolygon_${index}`;
                checkbox.checked = true;
                
                const label = document.createElement('label');
                label.htmlFor = `shapePolygon_${index}`;
                label.textContent = polygonData.name;
                label.style.fontSize = '13px';
                label.style.color = '#555';
                
                controlDiv.appendChild(checkbox);
                controlDiv.appendChild(label);
                controlsContainer.appendChild(controlDiv);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ—¢ã«åœ°å›³ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿è¿½åŠ 
                        if (!map.hasLayer(polygonData.layer)) {
                            map.addLayer(polygonData.layer);
                        }
                    } else {
                        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåœ°å›³ã«è¿½åŠ ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿å‰Šé™¤
                        if (map.hasLayer(polygonData.layer)) {
                            map.removeLayer(polygonData.layer);
                        }
                    }
                    // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°
                    updateShapeLayerMasterCheckbox();
                });
            });
            
            // åˆæœŸçŠ¶æ…‹ã§å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
            updateShapeLayerMasterCheckbox();
        }

        // GeoJSONãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’å‹•çš„ã«æ›´æ–°
        function updateGeoJSONPolygonControls() {
            const controlsContainer = document.getElementById('geojsonLayerControls');
            
            // æ—¢å­˜ã®å€‹åˆ¥ãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’å‰Šé™¤
            const existingPolygonControls = controlsContainer.querySelectorAll('.polygon-control');
            existingPolygonControls.forEach(control => control.remove());

            // å„ãƒãƒªã‚´ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¿½åŠ 
            overlayLayers.geojsonPolygons.forEach((polygonData, index) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'layer-item polygon-control';
                controlDiv.style.marginLeft = '20px'; // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `geojsonPolygon_${index}`;
                checkbox.checked = true;
                
                const label = document.createElement('label');
                label.htmlFor = `geojsonPolygon_${index}`;
                label.textContent = polygonData.name;
                label.style.fontSize = '13px';
                label.style.color = '#555';
                
                controlDiv.appendChild(checkbox);
                controlDiv.appendChild(label);
                controlsContainer.appendChild(controlDiv);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ—¢ã«åœ°å›³ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿è¿½åŠ 
                        if (!map.hasLayer(polygonData.layer)) {
                            map.addLayer(polygonData.layer);
                        }
                    } else {
                        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåœ°å›³ã«è¿½åŠ ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿å‰Šé™¤
                        if (map.hasLayer(polygonData.layer)) {
                            map.removeLayer(polygonData.layer);
                        }
                    }
                    // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°
                    updateGeoJSONLayerMasterCheckbox();
                });
            });
            
            // åˆæœŸçŠ¶æ…‹ã§å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
            updateGeoJSONLayerMasterCheckbox();
        }

        // èƒŒæ™¯åœ°å›³ã®åˆ‡ã‚Šæ›¿ãˆ
        document.querySelectorAll('input[name="basemap"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                map.removeLayer(currentBaseMap);
                currentBaseMap = baseMaps[e.target.value].addTo(map);
            });
        });

        // KMZãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†
        document.getElementById('kmzFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showStatus('KMZãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // KMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
                let kmlContent = null;
                for (const filename in zip.files) {
                    if (filename.toLowerCase().endsWith('.kml')) {
                        kmlContent = await zip.files[filename].async('text');
                        break;
                    }
                }

                if (kmlContent) {
                    // KMLã‚’GeoJSONã«å¤‰æ›
                    const parser = new DOMParser();
                    const kmlDoc = parser.parseFromString(kmlContent, 'text/xml');
                    const geoJson = toGeoJSON.kml(kmlDoc);

                    // æ—¢å­˜ã®KMZãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    overlayLayers.kmz.clearLayers();

                    // GeoJSONãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½œæˆ
                    const geoJsonLayer = L.geoJSON(geoJson, {
                        style: {
                            color: '#ff0000',
                            weight: 2,
                            opacity: 0.8,
                            fillOpacity: 0.3
                        },
                        onEachFeature: (feature, layer) => {
                            if (feature.properties) {
                                let popupContent = '<div style="max-width: 300px;">';
                                Object.entries(feature.properties).forEach(([key, value]) => {
                                    if (value) {
                                        popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                    }
                                });
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                        }
                    });

                    overlayLayers.kmz.addLayer(geoJsonLayer);
                    
                    // åœ°å›³ã®è¡¨ç¤ºç¯„å›²ã‚’èª¿æ•´
                    if (geoJsonLayer.getBounds().isValid()) {
                        map.fitBounds(geoJsonLayer.getBounds());
                    }

                    hideStatus();
                    console.log('KMZãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ');
                } else {
                    throw new Error('KMZãƒ•ã‚¡ã‚¤ãƒ«å†…ã«KMLãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                }

            } catch (error) {
                console.error('KMZãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('KMZãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                hideStatus();
            }
        });

        // GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†
        document.getElementById('geojsonFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showStatus('GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...');

            try {
                const text = await file.text();
                const geoJson = JSON.parse(text);

                // æ—¢å­˜ã®GeoJSONãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                overlayLayers.geojson.clearLayers();
                
                // æ—¢å­˜ã®å€‹åˆ¥ãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                overlayLayers.geojsonPolygons.forEach(polygonData => {
                    if (map.hasLayer(polygonData.layer)) {
                        map.removeLayer(polygonData.layer);
                    }
                });
                overlayLayers.geojsonPolygons = [];

                // é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’é™¤å»
                const uniqueFeatures = removeDuplicateFeatures(geoJson.features);
                const originalCount = geoJson.features.length;
                const uniqueCount = uniqueFeatures.length;
                
                if (originalCount > uniqueCount) {
                    console.log(`é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’é™¤å»ã—ã¾ã—ãŸ: ${originalCount}å€‹ã‹ã‚‰${uniqueCount}å€‹ã«å‰Šæ¸›`);
                }

                // é‡è¤‡é™¤å»å¾Œã®GeoJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                const uniqueGeoJson = {
                    type: "FeatureCollection",
                    features: uniqueFeatures
                };

                // åœ°å›³ã®è¡¨ç¤ºç¯„å›²ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ä¸€æ™‚çš„ãªGeoJSONãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆè¡¨ç¤ºã«ã¯ä½¿ç”¨ã—ãªã„ï¼‰
                const tempGeoJsonLayer = L.geoJSON(uniqueGeoJson);

                // å„ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚’å€‹åˆ¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦ä½œæˆ
                uniqueFeatures.forEach((feature, index) => {
                    // ãƒãƒªã‚´ãƒ³åã‚’å–å¾—ï¼ˆå±æ€§ã‹ã‚‰é©åˆ‡ãªåå‰ã‚’æ¢ã™ï¼‰
                    let polygonName = `GeoJSONãƒãƒªã‚´ãƒ³ ${index + 1}`;
                    if (feature.properties) {
                        // ã‚ˆãä½¿ã‚ã‚Œã‚‹åå‰ã®å±æ€§ã‚’æ¢ã™
                        const nameFields = ['name', 'NAME', 'label', 'LABEL', 'id', 'ID', 'title', 'TITLE'];
                        for (const field of nameFields) {
                            if (feature.properties[field]) {
                                polygonName = feature.properties[field];
                                break;
                            }
                        }
                    }

                    // å€‹åˆ¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½œæˆ
                    const individualLayer = L.geoJSON(feature, {
                        style: {
                            color: '#8B0000',        // æ¿ƒã„èµ¤è‰²ã®æ 
                            fillColor: '#FFA07A',    // è–„ã„èµ¤è‰²ã®å¡—ã‚Šã¤ã¶ã—
                            weight: 2,
                            opacity: 0.9,            // æ ã®é€æ˜åº¦
                            fillOpacity: 0.4         // å¡—ã‚Šã¤ã¶ã—ã®é€æ˜åº¦ï¼ˆ60%é€éï¼‰
                        },
                        onEachFeature: (feature, layer) => {
                            if (feature.properties) {
                                let popupContent = '<div style="max-width: 300px;">';
                                Object.entries(feature.properties).forEach(([key, value]) => {
                                    if (value) {
                                        popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                    }
                                });
                                popupContent += '</div>';
                                layer.bindPopup(popupContent);
                            }
                        }
                    });

                    // å€‹åˆ¥ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœ°å›³ã«è¿½åŠ 
                    individualLayer.addTo(map);

                    // ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    overlayLayers.geojsonPolygons.push({
                        name: polygonName,
                        layer: individualLayer,
                        feature: feature
                    });
                });

                // ãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°
                updateGeoJSONPolygonControls();
                
                // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹ï¼ˆå…¨ãƒãƒªã‚´ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ï¼‰
                document.getElementById('geojsonLayer').checked = true;
                
                // åœ°å›³ã®è¡¨ç¤ºç¯„å›²ã‚’èª¿æ•´
                if (tempGeoJsonLayer.getBounds().isValid()) {
                    map.fitBounds(tempGeoJsonLayer.getBounds());
                }

                hideStatus();
                
                // èª­ã¿è¾¼ã¿çµæœã‚’ãƒ­ã‚°ã¨ã‚¢ãƒ©ãƒ¼ãƒˆã§è¡¨ç¤º
                const resultMessage = originalCount > uniqueCount 
                    ? `GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ\nâ€¢ å…ƒã®ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼æ•°: ${originalCount}å€‹\nâ€¢ é‡è¤‡é™¤å»å¾Œ: ${uniqueCount}å€‹ã®ãƒãƒªã‚´ãƒ³\nâ€¢ é™¤å»ã•ã‚ŒãŸé‡è¤‡: ${originalCount - uniqueCount}å€‹`
                    : `GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸï¼ˆ${uniqueCount}å€‹ã®ãƒãƒªã‚´ãƒ³ï¼‰`;
                
                console.log(resultMessage);
                
                // é‡è¤‡ãŒã‚ã£ãŸå ´åˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
                if (originalCount > uniqueCount) {
                    showStatus(`é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’${originalCount - uniqueCount}å€‹é™¤å»ã—ã¾ã—ãŸ`);
                    setTimeout(hideStatus, 3000); // 3ç§’å¾Œã«éè¡¨ç¤º
                }

            } catch (error) {
                console.error('GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                hideStatus();
            }
        });

        // Shapeãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆZIPï¼‰ã®å‡¦ç†
        document.getElementById('shapeFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showStatus('Shapeãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡º
                let shpData = null;
                let dbfData = null;
                let prjData = null;

                for (const filename in zip.files) {
                    const file = zip.files[filename];
                    if (filename.toLowerCase().endsWith('.shp')) {
                        shpData = await file.async('arrayBuffer');
                    } else if (filename.toLowerCase().endsWith('.dbf')) {
                        dbfData = await file.async('arrayBuffer');
                    } else if (filename.toLowerCase().endsWith('.prj')) {
                        prjData = await file.async('text');
                    }
                }

                if (shpData && dbfData) {
                    // shapefileãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦GeoJSONã«å¤‰æ›
                    const geoJson = await shapefile.read(shpData, dbfData);

                    // æ—¢å­˜ã®Shapeãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    overlayLayers.shape.clearLayers();
                    
                    // æ—¢å­˜ã®å€‹åˆ¥ãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    overlayLayers.shapePolygons.forEach(polygonData => {
                        if (map.hasLayer(polygonData.layer)) {
                            map.removeLayer(polygonData.layer);
                        }
                    });
                    overlayLayers.shapePolygons = [];

                    // é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’é™¤å»
                    const uniqueFeatures = removeDuplicateFeatures(geoJson.features);
                    const originalCount = geoJson.features.length;
                    const uniqueCount = uniqueFeatures.length;
                    
                    if (originalCount > uniqueCount) {
                        console.log(`é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’é™¤å»ã—ã¾ã—ãŸ: ${originalCount}å€‹ã‹ã‚‰${uniqueCount}å€‹ã«å‰Šæ¸›`);
                    }

                    // é‡è¤‡é™¤å»å¾Œã®GeoJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                    const uniqueGeoJson = {
                        type: "FeatureCollection",
                        features: uniqueFeatures
                    };

                    // åœ°å›³ã®è¡¨ç¤ºç¯„å›²ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ä¸€æ™‚çš„ãªGeoJSONãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆè¡¨ç¤ºã«ã¯ä½¿ç”¨ã—ãªã„ï¼‰
                    const tempGeoJsonLayer = L.geoJSON(uniqueGeoJson);

                    // å„ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚’å€‹åˆ¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦ä½œæˆ
                    uniqueFeatures.forEach((feature, index) => {
                        // ãƒãƒªã‚´ãƒ³åã‚’å–å¾—ï¼ˆå±æ€§ã‹ã‚‰é©åˆ‡ãªåå‰ã‚’æ¢ã™ï¼‰
                        let polygonName = `ãƒãƒªã‚´ãƒ³ ${index + 1}`;
                        if (feature.properties) {
                            // ã‚ˆãä½¿ã‚ã‚Œã‚‹åå‰ã®å±æ€§ã‚’æ¢ã™
                            const nameFields = ['name', 'NAME', 'label', 'LABEL', 'id', 'ID', 'title', 'TITLE'];
                            for (const field of nameFields) {
                                if (feature.properties[field]) {
                                    polygonName = feature.properties[field];
                                    break;
                                }
                            }
                        }

                        // å€‹åˆ¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½œæˆ
                        const individualLayer = L.geoJSON(feature, {
                            style: {
                                color: '#001a33',        // æ¿ƒã„é’è‰²ã®æ 
                                fillColor: '#B0E0E6',    // è–„ã„æ°´è‰²ã®å¡—ã‚Šã¤ã¶ã—
                                weight: 2,
                                opacity: 0.9,            // æ ã®é€æ˜åº¦
                                fillOpacity: 0.4         // å¡—ã‚Šã¤ã¶ã—ã®é€æ˜åº¦ï¼ˆ60%é€éï¼‰
                            },
                            onEachFeature: (feature, layer) => {
                                if (feature.properties) {
                                    let popupContent = '<div style="max-width: 300px;">';
                                    Object.entries(feature.properties).forEach(([key, value]) => {
                                        if (value) {
                                            popupContent += `<strong>${key}:</strong> ${value}<br>`;
                                        }
                                    });
                                    popupContent += '</div>';
                                    layer.bindPopup(popupContent);
                                }
                            }
                        });

                        // å€‹åˆ¥ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœ°å›³ã«è¿½åŠ 
                        individualLayer.addTo(map);

                        // ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                        overlayLayers.shapePolygons.push({
                            name: polygonName,
                            layer: individualLayer,
                            feature: feature
                        });
                    });

                    // ãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°
                    updateShapePolygonControls();
                    
                    // å…¨ä½“ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹ï¼ˆå…¨ãƒãƒªã‚´ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ï¼‰
                    document.getElementById('shapeLayer').checked = true;
                    
                    // åœ°å›³ã®è¡¨ç¤ºç¯„å›²ã‚’èª¿æ•´
                    if (tempGeoJsonLayer.getBounds().isValid()) {
                        map.fitBounds(tempGeoJsonLayer.getBounds());
                    }

                    hideStatus();
                    
                    // èª­ã¿è¾¼ã¿çµæœã‚’ãƒ­ã‚°ã¨ã‚¢ãƒ©ãƒ¼ãƒˆã§è¡¨ç¤º
                    const resultMessage = originalCount > uniqueCount 
                        ? `Shapeãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ\nâ€¢ å…ƒã®ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼æ•°: ${originalCount}å€‹\nâ€¢ é‡è¤‡é™¤å»å¾Œ: ${uniqueCount}å€‹ã®ãƒãƒªã‚´ãƒ³\nâ€¢ é™¤å»ã•ã‚ŒãŸé‡è¤‡: ${originalCount - uniqueCount}å€‹`
                        : `Shapeãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸï¼ˆ${uniqueCount}å€‹ã®ãƒãƒªã‚´ãƒ³ï¼‰`;
                    
                    console.log(resultMessage);
                    
                    // é‡è¤‡ãŒã‚ã£ãŸå ´åˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
                    if (originalCount > uniqueCount) {
                        showStatus(`é‡è¤‡ãƒãƒªã‚´ãƒ³ã‚’${originalCount - uniqueCount}å€‹é™¤å»ã—ã¾ã—ãŸ`);
                        setTimeout(hideStatus, 3000); // 3ç§’å¾Œã«éè¡¨ç¤º
                    }
                } else {
                    throw new Error('å¿…è¦ãªShapeãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.shpã¾ãŸã¯.dbfï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                }

            } catch (error) {
                console.error('Shapeãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('Shapeãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                hideStatus();
            }
        });

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒªã‚¢æ©Ÿèƒ½
        document.getElementById('clearLayers').addEventListener('click', () => {
            // é€šå¸¸ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢
            overlayLayers.kmz.clearLayers();
            overlayLayers.shape.clearLayers();
            overlayLayers.geojson.clearLayers();
            
            // å€‹åˆ¥ãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢ï¼ˆShapeï¼‰
            overlayLayers.shapePolygons.forEach(polygonData => {
                if (map.hasLayer(polygonData.layer)) {
                    map.removeLayer(polygonData.layer);
                }
            });
            overlayLayers.shapePolygons = [];
            
            // å€‹åˆ¥ãƒãƒªã‚´ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢ï¼ˆGeoJSONï¼‰
            overlayLayers.geojsonPolygons.forEach(polygonData => {
                if (map.hasLayer(polygonData.layer)) {
                    map.removeLayer(polygonData.layer);
                }
            });
            overlayLayers.geojsonPolygons = [];
            
            // ãƒãƒªã‚´ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°ï¼ˆå‰Šé™¤ï¼‰
            const shapeControlsContainer = document.getElementById('shapeLayerControls');
            const existingShapePolygonControls = shapeControlsContainer.querySelectorAll('.polygon-control');
            existingShapePolygonControls.forEach(control => control.remove());
            
            const geojsonControlsContainer = document.getElementById('geojsonLayerControls');
            const existingGeoJSONPolygonControls = geojsonControlsContainer.querySelectorAll('.polygon-control');
            existingGeoJSONPolygonControls.forEach(control => control.remove());
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('kmzFile').value = '';
            document.getElementById('shapeFile').value = '';
            document.getElementById('geojsonFile').value = '';
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('kmzLayer').checked = true;
            document.getElementById('shapeLayer').checked = false; // Shapeãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„ã®ã§æœªãƒã‚§ãƒƒã‚¯
            document.getElementById('geojsonLayer').checked = false; // GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„ã®ã§æœªãƒã‚§ãƒƒã‚¯
            
            console.log('ã™ã¹ã¦ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¯ãƒªã‚¢ã•ã‚Œã¾ã—ãŸ');
        });

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºåˆ¶å¾¡
        document.getElementById('kmzLayer').addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(overlayLayers.kmz);
            } else {
                map.removeLayer(overlayLayers.kmz);
            }
        });

        document.getElementById('shapeLayer').addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            
            // å€‹åˆ¥ãƒãƒªã‚´ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ä¸€æ‹¬å¤‰æ›´
            overlayLayers.shapePolygons.forEach((polygonData, index) => {
                const checkbox = document.getElementById(`shapePolygon_${index}`);
                if (checkbox) {
                    checkbox.checked = isChecked;
                    
                    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡
                    if (isChecked) {
                        if (!map.hasLayer(polygonData.layer)) {
                            map.addLayer(polygonData.layer);
                        }
                    } else {
                        if (map.hasLayer(polygonData.layer)) {
                            map.removeLayer(polygonData.layer);
                        }
                    }
                }
            });
        });

        document.getElementById('geojsonLayer').addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            
            // å€‹åˆ¥ãƒãƒªã‚´ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ä¸€æ‹¬å¤‰æ›´
            overlayLayers.geojsonPolygons.forEach((polygonData, index) => {
                const checkbox = document.getElementById(`geojsonPolygon_${index}`);
                if (checkbox) {
                    checkbox.checked = isChecked;
                    
                    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡
                    if (isChecked) {
                        if (!map.hasLayer(polygonData.layer)) {
                            map.addLayer(polygonData.layer);
                        }
                    } else {
                        if (map.hasLayer(polygonData.layer)) {
                            map.removeLayer(polygonData.layer);
                        }
                    }
                }
            });
        });

        // åˆæœŸè¡¨ç¤ºæ™‚ã«ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•èª­ã¿è¾¼ã¿ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        window.addEventListener('load', () => {
            console.log('KMZ, Shape and GeoJSON Map Viewer has started');
            console.log('Select KMZ, Shape, or GeoJSON files to display on the map');
        });
    </script>
</body>
</html> 